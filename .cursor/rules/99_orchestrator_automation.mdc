---
alwaysApply: true
---

# ü§ñ AI Orchestrator Automation - Critical System Rule

## üéØ Purpose and Scope

This rule has the **HIGHEST PRIORITY** and automatically enables the AI Orchestrator for all Cursor agent tasks.
The Orchestrator supervises the agent by intelligently selecting optimal rules and execution strategies.

**IMPORTANT:** This rule **CANNOT BE DISABLED** ‚Äî it is critical for correct system operation.

## üöÄ Automatic Activation

### Prerequisites
```python
# The agent MUST verify these conditions BEFORE each task:
def check_orchestrator_prerequisites():
    """
    Check prerequisites for the orchestrator
    """
    # 1. Is the orchestrator service running?
    orchestrator_running = check_orchestrator_service()

    # 2. Is the API configuration available?
    config_available = check_ai_config()

    # 3. Are all required files present?
    files_available = check_orchestrator_files()

    return orchestrator_running and config_available and files_available
```

### Automatic Startup
```python
def ensure_orchestrator_running():
    """
    Automatically start the orchestrator if not running
    """
    if not check_orchestrator_service():
        logger.info("üöÄ Auto-starting AI Orchestrator Service...")

        # Start the service in background
        start_orchestrator_background()

        # Wait for initialization
        wait_for_orchestrator_ready(timeout=30)

        # Verify connection
        if not verify_orchestrator_connection():
            raise OrchestratorStartupError("Failed to start orchestrator service")

    logger.info("‚úÖ AI Orchestrator Service confirmed running")
```

## üéõÔ∏è Agent Integration

### Before Each Task
```python
def pre_task_orchestrator_integration(task_context):
    """
    Orchestrator integration before task execution
    """
    # 1. Ensure orchestrator is running
    ensure_orchestrator_running()

    # 2. Analyze the task with the orchestrator
    task_analysis = analyze_task_with_orchestrator(task_context)

    # 3. Get optimal rules for the task
    optimal_rules = select_optimal_rules_orchestrator(
        task_description=task_context['description'],
        current_file=task_context.get('file'),
        project_type=task_context.get('project_type')
    )

    # 4. Get the execution plan
    execution_plan = get_execution_plan_orchestrator(task_context['description'])

    # 5. Update task context
    task_context.update({
        'orchestrator_analysis': task_analysis,
        'optimal_rules': optimal_rules,
        'execution_plan': execution_plan,
        'orchestrator_supervised': True
    })

    return task_context
```

### During Execution
```python
def during_task_orchestrator_supervision(task_context, current_step):
    """
    Orchestrator supervision during task execution
    """
    # 1. Monitor progress
    progress_status = monitor_task_progress(current_step)

    # 2. Adjust strategy if needed
    if should_adjust_strategy(progress_status):
        new_strategy = get_adjusted_strategy_orchestrator(progress_status)
        apply_strategy_adjustment(new_strategy)

    # 3. Collect feedback for learning
    collect_execution_feedback(current_step)

    # 4. Validate compliance with optimal rules
    validate_rule_compliance(current_step, task_context['optimal_rules'])
```

### After Task Completion
```python
def post_task_orchestrator_learning(task_context, task_result):
    """
    Orchestrator learning after task completion
    """
    # 1. Assess execution results
    execution_assessment = assess_execution_quality(task_result)

    # 2. Send feedback to the learning system
    send_feedback_to_learning_system({
        'task': task_context,
        'result': task_result,
        'assessment': execution_assessment,
        'rules_used': task_context.get('optimal_rules', []),
        'execution_time': task_result.get('duration'),
        'success_rate': execution_assessment.get('success_score')
    })

    # 3. Update performance metrics
    update_performance_metrics(execution_assessment)

    # 4. Optimize future strategies
    optimize_future_strategies(execution_assessment)
```

## üìä Metrics and Monitoring

### Required Metrics
```python
ORCHESTRATOR_METRICS = {
    'service_uptime': 'percentage',           # Service uptime
    'task_supervision_rate': 'percentage',    # % of tasks supervised
    'rule_selection_accuracy': 'score',       # Rule selection accuracy
    'execution_plan_quality': 'score',        # Execution plan quality
    'learning_effectiveness': 'score',        # Learning effectiveness
    'api_response_time': 'milliseconds',      # API response time
    'error_recovery_rate': 'percentage'       # Error recovery success
}
```

### Critical Alerts
```python
CRITICAL_ALERTS = {
    'orchestrator_service_down': {
        'condition': 'service_uptime < 95%',
        'action': 'immediate_restart',
        'escalation': 'notify_admin'
    },
    'task_without_supervision': {
        'condition': 'task_supervision_rate < 100%',
        'action': 'log_warning',
        'escalation': 'investigate_skip_reason'
    },
    'poor_rule_selection': {
        'condition': 'rule_selection_accuracy < 0.8',
        'action': 'analyze_patterns',
        'escalation': 'update_training_data'
    }
}
```

## üîß Technical Implementation

### Required Files
```
.cursor/orchestrator/
‚îú‚îÄ‚îÄ ai_orchestrator.py              # Main orchestrator
‚îú‚îÄ‚îÄ ai_orchestrator_service.py      # HTTP API service
‚îú‚îÄ‚îÄ ai_orchestrator_client.py       # Client for the agent
‚îú‚îÄ‚îÄ ai_simple_config.py             # Config system
‚îú‚îÄ‚îÄ ai_config.json                  # API configuration
‚îú‚îÄ‚îÄ start_orchestrator.sh           # Startup script
‚îî‚îÄ‚îÄ test_full_integration.py        # Integration tests
```

### Imports in Rules
```python
# Required in every rule file:
from pathlib import Path
import sys
import os

# Add orchestrator path
orchestrator_path = Path(__file__).parent.parent / 'orchestrator'
if str(orchestrator_path) not in sys.path:
    sys.path.insert(0, str(orchestrator_path))

# Import the client
try:
    from ai_orchestrator_client import (
        select_optimal_rules,
        get_execution_plan,
        analyze_code_for_insights,
        get_project_context,
        AIOrchestratorClient
    )
    ORCHESTRATOR_AVAILABLE = True
except ImportError:
    ORCHESTRATOR_AVAILABLE = False
    logger.warning("AI Orchestrator not available - using fallback mode")
```

### Fallback Mode
```python
def orchestrator_fallback(task_context):
    """
    Fallback when orchestrator is unavailable
    """
    logger.warning("Using orchestrator fallback - limited functionality")

    # Use baseline rules
    fallback_rules = ['30_hybrid_moe_tot_reasoning', '31_advanced_agent_steering']

    # Simple execution plan
    fallback_plan = {
        'Planning': {'tasks': ['Analyze requirements'], 'estimated_hours': 1},
        'Implementation': {'tasks': ['Execute task'], 'estimated_hours': 2},
        'Testing': {'tasks': ['Basic validation'], 'estimated_hours': 1}
    }

    return {
        'rules': fallback_rules,
        'plan': fallback_plan,
        'fallback_mode': True
    }
```

## üö® Security and Compliance

### API Security
- All orchestrator calls must use a secure protocol
- API keys must never be logged or exposed
- Communication must be encrypted (HTTPS in production)

### Compatibility with Existing Rules
- This rule **DOES NOT OVERRIDE** other rules
- It **COMPLEMENTS** them by intelligently selecting optimal combinations
- It **STRENGTHENS** existing rules through supervision and optimization

### Error Handling
```python
def handle_orchestrator_errors(error, context):
    """
    Safe handling of orchestrator errors
    """
    error_types = {
        'connection_error': 'retry_with_backoff',
        'timeout_error': 'use_cached_results',
        'api_error': 'fallback_to_local_logic',
        'config_error': 'notify_user_setup_required'
    }

    error_type = classify_error(error)
    action = error_types.get(error_type, 'log_and_continue')

    execute_error_action(action, error, context)

    # Always ensure a fallback
    return ensure_fallback_available(context)
```

## üìà System Benefits

### For the Cursor Agent
- **Smarter decision-making** - optimal strategy selection
- **Continuous optimization** - learning from experience
- **Better outcomes** - higher execution quality
- **Automatic adaptation** - context-aware behavior

### For Developers
- **Transparency** - clear supervision over the agent
- **Configurable behavior** - adjustable strategies
- **Reliability** - automatic error recovery
- **Monitoring** - full process visibility

### For the Project
- **Higher code quality** - intelligent use of best practices
- **Faster delivery** - optimal plans and strategies
- **Reduced risk** - supervision and validation
- **Continuous improvement** - learning system

---

## üîí Status: CRITICAL SYSTEM RULE

**This rule has the highest priority and cannot be modified without administrator approval.**

**Violating this rule may lead to:**
- Loss of supervision over the agent
- Reduced execution quality
- Disabled learning capabilities
- Lower overall efficiency

**Recommended actions:**
1. Ensure continuous access to the orchestrator
2. Monitor performance metrics
3. Regularly update configuration
4. Report integration issues

## üéõÔ∏è Integracja z Agentem

### Przed Ka≈ºdym Zadaniem
```python
def pre_task_orchestrator_integration(task_context):
    """
    Integracja orchestratora przed wykonaniem zadania
    """
    # 1. Upewnij siƒô ≈ºe orchestrator dzia≈Ça
    ensure_orchestrator_running()

    # 2. Przeanalizuj zadanie z orchestratorem
    task_analysis = analyze_task_with_orchestrator(task_context)

    # 3. Pobierz optymalne rules dla zadania
    optimal_rules = select_optimal_rules_orchestrator(
        task_description=task_context['description'],
        current_file=task_context.get('file'),
        project_type=task_context.get('project_type')
    )

    # 4. Pobierz plan wykonania
    execution_plan = get_execution_plan_orchestrator(task_context['description'])

    # 5. Zaktualizuj kontekst zadania
    task_context.update({
        'orchestrator_analysis': task_analysis,
        'optimal_rules': optimal_rules,
        'execution_plan': execution_plan,
        'orchestrator_supervised': True
    })

    return task_context
```

### Podczas Wykonywania
```python
def during_task_orchestrator_supervision(task_context, current_step):
    """
    Nadz√≥r orchestratora podczas wykonania zadania
    """
    # 1. Monitoruj postƒôp
    progress_status = monitor_task_progress(current_step)

    # 2. Je≈õli potrzebne - dostosuj strategiƒô
    if should_adjust_strategy(progress_status):
        new_strategy = get_adjusted_strategy_orchestrator(progress_status)
        apply_strategy_adjustment(new_strategy)

    # 3. Zbieraj feedback dla uczenia siƒô
    collect_execution_feedback(current_step)

    # 4. Waliduj zgodno≈õƒá z optymalnymi rules
    validate_rule_compliance(current_step, task_context['optimal_rules'])
```

### Po Zako≈Ñczeniu Zadania
```python
def post_task_orchestrator_learning(task_context, task_result):
    """
    Uczenie siƒô orchestratora po zako≈Ñczeniu zadania
    """
    # 1. Oce≈Ñ wyniki wykonania
    execution_assessment = assess_execution_quality(task_result)

    # 2. Wy≈õlij feedback do systemu uczenia siƒô
    send_feedback_to_learning_system({
        'task': task_context,
        'result': task_result,
        'assessment': execution_assessment,
        'rules_used': task_context.get('optimal_rules', []),
        'execution_time': task_result.get('duration'),
        'success_rate': execution_assessment.get('success_score')
    })

    # 3. Zaktualizuj metryki wydajno≈õci
    update_performance_metrics(execution_assessment)

    # 4. Optymalizuj przysz≈Çe strategie
    optimize_future_strategies(execution_assessment)
```

## üìä Metryki i Monitorowanie

### Wymagane Metryki
```python
ORCHESTRATOR_METRICS = {
    'service_uptime': 'percentage',           # Czas dzia≈Çania serwisu
    'task_supervision_rate': 'percentage',    # % zada≈Ñ nadzorowanych
    'rule_selection_accuracy': 'score',       # Dok≈Çadno≈õƒá wyboru rules
    'execution_plan_quality': 'score',        # Jako≈õƒá plan√≥w wykonania
    'learning_effectiveness': 'score',        # Efektywno≈õƒá uczenia siƒô
    'api_response_time': 'milliseconds',      # Czas odpowiedzi API
    'error_recovery_rate': 'percentage'       # Skuteczno≈õƒá odzyskiwania b≈Çƒôd√≥w
}
```

### Alerty Krytyczne
```python
CRITICAL_ALERTS = {
    'orchestrator_service_down': {
        'condition': 'service_uptime < 95%',
        'action': 'immediate_restart',
        'escalation': 'notify_admin'
    },
    'task_without_supervision': {
        'condition': 'task_supervision_rate < 100%',
        'action': 'log_warning',
        'escalation': 'investigate_skip_reason'
    },
    'poor_rule_selection': {
        'condition': 'rule_selection_accuracy < 0.8',
        'action': 'analyze_patterns',
        'escalation': 'update_training_data'
    }
}
```

## üîß Implementacja Techniczna

### Wymagane Pliki
```
.cursor/orchestrator/
‚îú‚îÄ‚îÄ ai_orchestrator.py              # G≈Ç√≥wny orchestrator
‚îú‚îÄ‚îÄ ai_orchestrator_service.py      # HTTP API service
‚îú‚îÄ‚îÄ ai_orchestrator_client.py       # Klient dla agenta
‚îú‚îÄ‚îÄ ai_simple_config.py             # Config system
‚îú‚îÄ‚îÄ ai_config.json                  # Konfiguracja API
‚îú‚îÄ‚îÄ start_orchestrator.sh           # Skrypt startowy
‚îî‚îÄ‚îÄ test_full_integration.py        # Testy integracyjne
```

### Importy w Rules
```python
# W ka≈ºdej rules wymagane jest:
from pathlib import Path
import sys
import os

# Dodaj ≈õcie≈ºkƒô do orchestratora
orchestrator_path = Path(__file__).parent.parent / 'orchestrator'
if str(orchestrator_path) not in sys.path:
    sys.path.insert(0, str(orchestrator_path))

# Importuj klienta
try:
    from ai_orchestrator_client import (
        select_optimal_rules,
        get_execution_plan,
        analyze_code_for_insights,
        get_project_context,
        AIOrchestratorClient
    )
    ORCHESTRATOR_AVAILABLE = True
except ImportError:
    ORCHESTRATOR_AVAILABLE = False
    logger.warning("AI Orchestrator not available - using fallback mode")
```

### Fallback Mode
```python
def orchestrator_fallback(task_context):
    """
    Fallback gdy orchestrator nie jest dostƒôpny
    """
    logger.warning("Using orchestrator fallback - limited functionality")

    # U≈ºyj podstawowych rules
    fallback_rules = ['30_hybrid_moe_tot_reasoning', '31_advanced_agent_steering']

    # Prosty plan wykonania
    fallback_plan = {
        'Planning': {'tasks': ['Analyze requirements'], 'estimated_hours': 1},
        'Implementation': {'tasks': ['Execute task'], 'estimated_hours': 2},
        'Testing': {'tasks': ['Basic validation'], 'estimated_hours': 1}
    }

    return {
        'rules': fallback_rules,
        'plan': fallback_plan,
        'fallback_mode': True
    }
```

## üö® Bezpiecze≈Ñstwo i Zgodno≈õƒá

### Bezpiecze≈Ñstwo API
- Wszystkie wywo≈Çania do orchestratora muszƒÖ u≈ºywaƒá bezpiecznego protoko≈Çu
- API keys nigdy nie mogƒÖ byƒá logowane lub ujawniane
- Komunikacja musi byƒá szyfrowana (HTTPS w produkcji)

### Zgodno≈õƒá z IstniejƒÖcymi Rules
- Ta regu≈Ça **NIE NADPISUJE** innych rules
- **UZUPE≈ÅNIA** je poprzez inteligentne wybieranie optymalnych kombinacji
- **WZMACNIA** istniejƒÖce regu≈Çy poprzez nadzor i optymalizacjƒô

### Obs≈Çuga B≈Çƒôd√≥w
```python
def handle_orchestrator_errors(error, context):
    """
    Bezpieczna obs≈Çuga b≈Çƒôd√≥w orchestratora
    """
    error_types = {
        'connection_error': 'retry_with_backoff',
        'timeout_error': 'use_cached_results',
        'api_error': 'fallback_to_local_logic',
        'config_error': 'notify_user_setup_required'
    }

    error_type = classify_error(error)
    action = error_types.get(error_type, 'log_and_continue')

    execute_error_action(action, error, context)

    # Zawsze zapewnij fallback
    return ensure_fallback_available(context)
```

## üìà Korzy≈õci Systemu

### Dla Agenta Cursor
- **Inteligentne podejmowanie decyzji** - wyb√≥r optymalnych strategii
- **CiƒÖg≈Ça optymalizacja** - uczenie siƒô z do≈õwiadcze≈Ñ
- **Lepsze wyniki** - wy≈ºsza jako≈õƒá wykonania zada≈Ñ
- **Automatyczna adaptacja** - dostosowanie do kontekstu projektu

### Dla Dewelopera
- **Przejrzyste dzia≈Çanie** - jasny nadz√≥r nad agentem
- **Konfigurowalne zachowanie** - mo≈ºliwo≈õƒá dostosowania strategii
- **Niezawodno≈õƒá** - automatyczne odzyskiwanie po b≈Çƒôdach
- **Monitorowanie** - pe≈Çna widoczno≈õƒá proces√≥w

### Dla Projektu
- **Wy≈ºsza jako≈õƒá kodu** - inteligentne stosowanie najlepszych praktyk
- **Szybsze wykonywanie** - optymalne plany i strategie
- **Mniejsze ryzyko b≈Çƒôd√≥w** - nadzor i walidacja
- **CiƒÖg≈Çe doskonalenie** - system uczenia siƒô

---

## üîí Status: CRITICAL SYSTEM RULE

**Ta regu≈Ça ma najwy≈ºszy priorytet i nie mo≈ºe byƒá modyfikowana bez zgody administratora systemu.**

**Naruszenie tej regu≈Çy mo≈ºe prowadziƒá do:**
- Utraty nadzoru nad agentem
- Pogorszenia jako≈õci wykonania zada≈Ñ
- Brak mo≈ºliwo≈õci uczenia siƒô systemu
- Obni≈ºenia efektywno≈õci pracy

**Recommended actions:**
1. Ensure continuous access to the orchestrator
2. Monitor performance metrics
3. Regularly update configuration
4. Report integration issues